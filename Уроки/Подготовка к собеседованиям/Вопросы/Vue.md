## Что такое data
**data** - **метод** компонента, который возвращает **объект** с данными. Vue будет на этапе создания компонента обернет этот объект в свою систему реактивности и сохранит как **$data**

Другими словами, этот метод нужен для определения основных переменных, которые создаются внутри компонента, используются им, изменяются, передаются в другие компоненты и так далее.

```vue
<template>
	<h1>{{ header }}</h1>	
</template>
<script>
	export default {
		data() {
			return {
				header: "Hello User!"
			}
		}
	}
</script>
```

## Что такое methods
**methods** - это **свойство** компонента, которое содержит **объект** со всеми **методами**, которые использует этот компонент

```vue
<template>
	<input ref="myInput"/>
	<button @click="showInputValue"></button>
</template>
<script>
	export default {
		methods: {
			showInputValue() {
				alert(this.$refs.myInput.value)
			}
		}
	}
</script>
```

## Что такое props
**props** - свойство, определяющее входные параметры компонента, то есть те данные, которые он может принимать извне.
Так как у нас компоненты должны взаимодействовать друг с другом, без этого не обойтись.

Может быть определено в виде массива или объекта с типами данных:
```vue
<script>
	export default {
		props: ['show', 'text', 'count', 'items']
	}
</script>
```

```vue
<script>
	export default {
		props: {
			show: Boolean,
			text: String,
			count: Number,
			items: Array
		}
	}
</script>
```

## Что такое computed
**computed** - объект, содержащий **вычисляемые** свойства компонента.

## Что такое вычисляемое свойство
**Вычисляемое свойство** - свойство, значение которого вычисляется на основе других данных при обращении к нему.

Пример:
```vue
<template>
	<div>
		<p>Изначальное сообщение: «{{ message }}»</p>
		<p>Сообщение задом наперёд: «{{ reversedMessage }}»</p>
	</div>
</template>
<script>
	export default {
		data() {
			return {
				message: 'Hello'
			}
		},
		computed: {
			reversedMessage: function () {
				return this.message.split('').reverse().join('')
			}
		}
	}
</script>
```

**Важно:** какой смысл вычисляемых свойств, если мы можем просто создать метод **getReversedMessage**, который будет делать то же самое?

Ответ - вычисляемые свойства **кэшируются, основываясь на своих реактивных зависимостях.**
Теперь нормальными словами: когда мы первый раз обратимся к вычисляемому свойству, оно будет вычислено и **запомнено в памяти.**
При следующих обращениях оно не будет вычисляться, а сразу же возьметься оттуда.
А что, если изменятся переменные, из которых это свойство было вычислено?
Все будет ок, потому что Vue следит за всеми **зависимостями** этого вычисляемого свойства и вычисляет его заново каждый раз, когда одна из этих зависимостей вдруг меняет свое значение.
В примере выше вычисляемым свойством является **reversedMessage**, а его зависимостью - переменная **message**.

Зачем это нужно? Представим, что у нас есть вычисляемое значение, которое очень сложно и дорого вычислять, однако оно очень часто используется, но в то же время его значение редко меняется. 
В таком случае нам как раз очень выгодно вычислить его значение один раз, а в остальных случаях моментально брать его из памяти, пересчитывая только при необходимости.

## Что такое односторонее и двусторонее связывание
Во Vue под этими понятиями обычно подразумевают **v-bind** в первом случае и **v-model** во втором.

Тут все просто. Есть односторонняя связь между данными А и Б. Если переменная А изменится, то сразу же изменится переменная Б. Однако, если изменится Б, то изменение переменной А за этим не последует, так как связь односторонняя. Пример:

```vue
<template>  
  <input v-bind:value="inputValue"/>  
</template>  
  
<script>  
export default {  
  name: "Test.vue",  
  data() {  
    return {  
      inputValue: "Hello" 
    }  
  }  
}  
</script>
```

Если изменить переменную inputValue, то сразу же поменяется значение внутри инпута.
Однако, если поменять его в инпуте вручную на сайте и глянуть через Vue DevTools значение перменной inputValue - оно останется прежним.

**Теперь создадим двусторонее связывание**
Подобно тому, как все элементы отправляют событие *click* при нажатии на них, элемент с тегом **input** отправляет одноименное событие *input*, когда текст внутри него меняют, подпишемся на него:

```vue
<template>  
  <input :value="inputValue" 
		 @input="inputValue = $event.target.value"/>  
</template>  
  
<script>  
export default {  
  name: "Test.vue",  
  data() {  
    return {  
      inputValue: "Hello" 
    }  
  }  
}  
</script>
```

Теперь, когда на сайте мы изменяем значение внутри инпута, он отправляет событие *input*, мы его ловим и сразу же изменяем значение нашей переменной.

Такой прием использовался очень часто разработчиками, что неудивительно, ведь мы постоянно работаем с формами, поэтому создатели Vue решили сделать для этой записи отдельную директиву **v-model:**

Альтернативная запись прошлого кода:
```vue
<template>  
  <input v-model="inputValue"/>  
</template>  
  
<script>  
export default {  
  name: "Test.vue",  
  data() {  
    return {  
      inputValue: "Hello" 
    }  
  }  
}  
</script>
```

## Что такое реактивность и как она используется во Vue
Это понятие можно объяснить разными способами, но по сути это возможность данных моментально реагировать на изменение их зависимостей.

То есть если переменная А зависит от переменных Б и С, то при изменении одной из них значение переменной А будет сразу же пересчитано.

Во Vue мы замечали это уже довольно много раз, к примеру, когда мы используем внутри шаблона переменную из data, при изменении, она реактивно перерисовывается.
В других случаях мы передавали переменную в дочерний компонент через v-bind и при изменении этой переменной она реактивно изменялась в ребенке.

**Как это реализовано во Vue**
В Vue 2 и в Vue 3 реактивность реализована совершенно по-разному, однако базовые принципы остаются во всех фреймворках одинаковыми.

При создании переменных, за значениями которых нужно следить (к примеру внутри data), Vue создает над ними proxy или геттеры/сеттеры через Object.defineProperty, которые следят за обращениями к свойству и попытке его изменить. 
Эти оболочки как раз и заняты тем, что сразу же реактивно изменяют все зависимости либо уведомляют наблюдателей.

**Пример**
Пусть у нас есть страничка, на которой отображается количество лайков и есть кнопка "поставить лайк":

Как бы мы это сделали через голый JS:
```html
<div id="container">Количество лайков = 0</div>
<button id="btn">Поставить лайк</button>
```

```js
const btn = document.getElementById('btn')
const container = document.getElementById('container')

let counter = 0

btn.addEventListener('click', () => {
	counter += 1
	container.innerText = `Количество лайков = ${ counter }`
})
```

То есть помимо концентрации на логике, мы еще должны думать о визуальном представлении данных и не забывать их менять при каждом изменении данных.

Как бы сделали через Vue:
```vue
<template>
	<div>Количество лайков = {{ likes }}</div>
	<button @click="likes += 1">Поставить лайк</button>
</template>
<script>
	export default {
		data() {
			return {
				likes: 0
			}
		}
	}
</script>
```

И мы видим, что при изменении переменной likes, компонент будет реактивно перерендериваться под новое значение, нам не нужно делать это вручную, можем занять свою голову только логикой.

## Разница в v-model в Vue 2 и Vue 3
В Vue 2 **v-model** используется как сокращение для следующей записи:
```vue
<template>  
  <input :value="inputValue" 
		 @input="inputValue = $event.target.value"/>  
</template>  
```

```vue
<template>  
  <input v-model="inputValue"/>  
</template>  
```

То есть он по умолчанию использует **value** в качестве значения для **v-bind** и подписывается на событие **input** для обновления этго значения.

Если мы хотим использовать **v-model** на собственном компоненте, нужно определить его следующим образом:

*Child.vue*
```vue
<template>
	<input ref="myInput"/>
	<button @click="changeValue">Изменить value</button>
</template>

<script>
export default {
	props: {
		value: String // Может быть любого типа
	},
	methods: {
		changeValue() {
			this.$emit('input', this.$refs.myInput.value)
		}
	}
}
</script>
```

То есть он один в один как элемент **\<input/\>** должен принимать **value** на вход и отправлять событие **input**, когда хочет изменить это значение.

Теперь мы сможем делать так:
*Parent.vue*
```vue
<template>
	<child v-model="childValue"></child>
</template>

<script>
import Child from './components/Child.vue'

export default {
	components: { Child },
	data() {
		return {
			childValue: 'Hello'
		}
	}
</script>
```

Потом разрабы начали сталкиваться с проблемой, что хочется организовать **двусторонее связывание** с несколькими переменными, а мы ограничены только одной **value**.

Решение пришло с версией Vue 3:
Теперь мы можем указывать название переменной, с которой будет установлено двусторонее связывание, для этого нужно написать ее название после v-model через двоеточие:

```vue
<template>
	<child v-model:title="childTitle" 
		   v-model:body="childBody" 
		   v-model:email="childEmail">
	</child>
</template>
```

Если не указывать ее название, то по умолчанию будет использоваться переменная с именем **modelValue**

Для того, чтобы это работало, нужно также изменить способ отправления ивента внутри дочернего компонента. 
Мы уже не можем просто отправлять **input** так как реактивно используем не одну переменную.
Для этого во Vue нужно писать названия по следующему шаблону:
```js
this.$emit('update:title', title)
this.$emit('update:body', body)
this.$emit('update:email', email)
```

Vue сам понимает, что, раз мы пишем update, то собираемся взаимодействовать с v-model и устанавливает связь.

## Взаимодействие между компонентами

Родительский компонент взаимодействует с дочерним, передавая в него данные через **props**.

Передать может статически
```vue
<child value="Значение"></child>
```

Через v-bind (Односторонняя связь)
```vue
<template>
	<child v-bind:value="childValue"></child>
</template>
<script>
export default {
	data() {
		return {
			childValue: 'Значение'
		}
	}
}
</script>
```

Через v-model (Двустороняя связь)
```vue
<template>
	<child v-model:value="childValue"></child>
</template>
<script>
export default {
	data() {
		return {
			childValue: 'Значение'
		}
	}
}
</script>
```

Дочерний может взаимодействовать с родительским, отправляя события

*Child.vue*
```vue
<template>
	<button @click="$emit('notify')">Уведомить родителя</button>
</template>
```

*Parent.vue*
```vue
<template>
	<child @notify="doSomething"></child>
</template>
```

## Постраничная навигация во Vue
Для этого используется библиотека **vue-router**
С помощью нее можем создать роутер, в котором указать массив маршрутов.
В маршруте указываем путь к нему и компонент, который будет отрисовываться.

*router.js*
```js
const router = createRouter({
	routes: [
		{ path: '/', component: Main },
		{ path: '/about', component: About }
	],
	history: createWebHistory()
})
```

Далее этот роутер регистрируем в App

*main.js*
```js
createApp(App).use(router)
```

Для того, чтобы монтировать компонент, который должен отрисовываться по определенному пути, используется компонент **router-view**
```html
<div class="app">
	<router-view></router-view>
</div>
```

А для навигации используем не обычные ссылки, а компонент **router-link**