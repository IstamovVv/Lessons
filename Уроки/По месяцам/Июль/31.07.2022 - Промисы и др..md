
Существуют функции *Math.max(arg1, arg2, ...)* и *Math.min(arg1, arg2, ...)*

В них можно передавать сколько угодно аргументов и она найдет максимальный из них
```js
console.log(Math.max(1, 2, 3, 4, 5)) // 5
```
Как она работает?

# Псевдомассив arguments
Со старых времен внутри любой функции можно было обратиться к *псевдомассиву* arguments, который хранит в себе все значения аргументов функции.
```js
function test() {
	console.log(arguments)
}

test(1,2,3,4,5)
```

# Остаточные параметры и оператор расширения

В JS в функцию можно передать сколько угодно параметров
```js
function test(a, b) {
	console.log(a)
	console.log(b)
}

test(1, 2, 3, 4, 5)
```
Ненужные будут банально выброшены

Либо не передать вовсе
```js
test()
```
В таком случае a и b будут равны undefined.

Понятие *остаточные параметры*
Синтаксис следующий:
```js
function test(a, b, ...rest) {
	// some code
}
```

Пишем три точки перед названием аргумента, в таком случае первые два переданных параметра будут занесены в *a* и *b*, а остальные в *массив* rest.

```js
function test(a, b, ...rest) {
	console.log(a) // 1
	console.log(b) // 2
	console.log(rest) // [3,4,5,6]
}

test(1,2,3,4,5,6)
```

Можно написать сразу так, никто не запрещает
```js
function test(...rest) {

}
```

Тогда вообще все аргументы будут занесены в *массив* rest.
Плюс не обязательно называть *rest*, это не зарезервированное понятие.

Если же использовать такой синтаксис на *перебираемые объекты*, то это будет называться *оператор расширения*

Он просто раскрывает массив
```js
Math.max(1, 2, 3, 4)
Math.max(...[1, 2, 3, 4]) // Абсолютно то же самое
```

Так как это работает со всеми *перебираемыми объектами*, аналогично можно разложить, к примеру строку

```js
console.log(..."string") // s,t,r,i,n,g
```

https://learn.javascript.ru/rest-parameters-spread-operator

# setTimeout, setInterval
Это функции, позволяющие вызвать нужный код через определенный промежуток времени, синтаксис следующий:
```js
setTimeout(callback, 1000, param1, param2, ...)
```

То есть сначала передаем функцию, которую надо будет вызвать.
Следующим параметром указываем время, через которое вызвать (в миллисекундах)
И все остальные параметры будут восприниматься как аргументы для коллбека.

```js
setTimeout(function() {
	console.log('Прошло 2 секунды')
}, 2000)
```

setTimeout срабатывает один раз.
Если мы хотим, чтобы эта функция вызывалась *каждые* две секунды, то нам поможет *setInterval*

```js
let count = 0;

setInterval(function() {
	count += 1;
	console.log('Прошло ' + count + ' секунд')
}, 1000)
```

Эти функции помогут нам для имитации асинхронных операций.
https://learn.javascript.ru/settimeout-setinterval

Также *setTimeout* и *setInterval* возвращают *id*, по которому можно этот таймер остановить.

```js
const timeoutId = setTimeout(() => {}, 1000)
clearTimeout(timeoutId)

const intervalId = setInterval(() => {}, 1000)
clearInterval(intervalId)
```

# Коллбеки
*callback* - функция обратного вызова.

Если из википедии, то
**Callback** (call — вызов, back — обратный) или **фу́нкция обра́тного вы́зова** в программировании — передача исполняемого кода в качестве одного из параметров другого кода.

Это фундаментальное понятие на уровне молотка и гвоздя, примеров тут уйма от знакомых *forEach(callback)* до алгоритмов вычисления хеш значений.

Так как следующей темой будут промисы, заострим внимание на том, что их также используют для отложенного выполнения кода.

```js
function loadData(onLoad) {
  // some requests to the server
  setTimeout(() => {
    onLoad()
  }, 5000)
}

console.log("loading...")
loadData(() => {
  console.log('Data Loaded!')
})
```

https://learn.javascript.ru/callbacks

# Промисы
*Promise* или *Обещания* - это встроенные объекты, позволяющие удобно работать с асинхронными операциями.

Синтакис следующий:
```js
const promise = new Promise(executor)
```

*executor (исполнитель)* - это функция, которая выполняет обещание. Как в примере с коллбеками, она внутри себя делает кучу магических вещей, отправляет запросы, запускает таймауты и прочие вещи, до которых внешнему коду нет никакого дела.

Эта функция должна иметь 2 аргумента
```js
function executor(resolve, reject) {}
```

Эти 2 аргумента оба являются коллбеками.
Работает это так, когда эта функция внутри себя выполнила все нужные ей дела и все ок, она в конце вызывает *resolve()*

Если же произошла ошибка или что-то пошло не так, она вызывает *reject()*

```js
function executor(resolve, reject) {
	setTimeout(() => {
		if (звезды сошлись) {
			resolve()
		} else {
			reject()
		}
	}, 5000)
}
```

Эти функции *resolve* и *reject* ей передает сам объект *Promise*.
Их задача - поменять состояние Обещания.

Promise имеет три состояния:
- *pending* (Ожидающий)
- *fulfilled*  (Выполненный) (синоним слова resolved)
- *rejected* (Отклоненный)

Когда мы создали промис, он находится в состоянии *ожидания*, то есть *pending*

Когда *executor* вызывает *resolve*, *промис* переходит в состояние *fulfilled*.
Когда *executor* вызывает *reject*, *промис* переходит в состояние *rejected*.

Пока что мы видим, что в зависимости от результата, он только и делает, что меняет свое состояние, но в чем смысл?
В том, что он делает не только это.

## Метод then
Здесь нам пригождается *метод* объекта *Promise* - *then*.
Синтаксис следующий:
```js
Promise.then(onResolve, onReject)
```

Грубо говоря, когда мы вызываем *then*, *промис* сохраняет у себя переданные в аргументах коллбеки, запоминая, что, вот когда я разрешусь, я вызову *onResolve*, а если будет ошибка, я вызову *onReject*.

## Важно в правильной последовательности читать код

```js
const promise = new Promise(function(resolve, reject) {
	setTimeout(() => {
		resolve()
	}, 5000)
})

function onResolved() {
	console.log('Resolved')
}

function onRejected() {
	console.log('Rejected')
}

promise.then(onResolved, onRejected)
```

Код после new Promise(...)
Выполнится сразу же в прямой последовательности, то есть он не будет ждать таймаута.

JS просто видит, что мы создали какой то объект, ему плевать что он будет ждать лишь выполнения функции-конструктора.
В случае с промисом, он в конструкторе просто создаст функции resolve, reject, кинет их в executor и вернет исполнение внешнему коду

```js
function Promise(executor) {
	this.state = "pending"
	
	this.onResolved = null
	this.onRejected = null
	
	executor(this.resolve, this.reject)
	
	function resolve(...args) {
		this.state = "fulfilled"
		if (this.onResolved) this.onResolved(...args)
	}
	
	function reject(...args) {
		this.state = "rejected"
		if (this.onRejected) this.onRejected(...args)
	}

	this.then = function(onResolved, onRejected) {
		this.onResolved = onResolved;
		this.onRejected = onRejected;
	}
}
```

*Помимо then* у промисов есть еще методы *catch* и *finally*.

```js
Promise.catch(callback)
Promise.finally(callback)
```

Они оба принимают коллбеки.
Коллбек, указанный в *catch* сработает, если возникла какая то ошибка (то есть точно так же, как и *onReject*)

Коллбек, указанный в *finally* сработает в *любом случае*, выполнился промис или отклонился. 

Finally указывает на то, что executor закончил свою работу и можно сделать что то окончательное, не зависящее от результата обещания.

Далее разрабы задумались, у нас есть цепочка коллбэков, нам часто приходится выполнять асинхронные задачи друг за другом, чтобы они ждали того, кто следующий. 
Прикинули, что было бы круто, если бы выглядело это примерно так
```
promise.then().then().then().then()
```

Очень распространенный прием в программировании, когда, к примеру, функция возвращает функцию, чтобы можно было делать так:
```js
sum(1)(2)(3)(4) // 10
```

В нашем же случае вызывается метод, поэтому нужно возвращать не функцию, а объект.
Собственно, выглядит это следующим образом:
```js
new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000); // (*)

}).then(function(result) { // (**)

  alert(result); // 1
  return result * 2;

}).then(function(result) { // (***)

  alert(result); // 2
  return result * 2;

}).then(function(result) {

  alert(result); // 4
  return result * 2;

});
```

Чтобы это сработало, метод *then* возвращает новый *промис*, *executor-ом* в котором будет являться *onResolved* коллбэк, который мы как раз передаем в этот *then*.
