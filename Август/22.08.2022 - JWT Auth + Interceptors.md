
> 
> 6 часов дебага могут сэкономить 5 минут чтения документации
> - Джейсон Стетхем
> 

# Что такое JWT
### Кратко и просто

Это *ключ*, который словно вахтер нам выдает сервер после того, как мы авторизовались. 
После этого при любом запросе на сервер мы прикладываем этот ключ, чтобы сервер проверил, что этот запрос прислал не абы кто, а авторизованный пользователь.

### Чуть подробнее

**JWT (JSON Web Token)** - один из безопасных способов передачи данных между двумя сторонами. 

Представляет из себя строку вида:
- **header.payload.signature**

Где
- header - информация о том, как должен вычисляться JWT
- payload - полезные данные внутри JWT
- signature - подпись, то есть сам секретный ключ

**Header** выглядит примерно так:
```json
{ "alg": "HS256", "typ": "JWT" }
```

**Payload**:
```json
{ "userId": "b08f86af-35da-48f2-8fab-cef3904660bd" }
```

**Signature**
```json
-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```

После этого все эти данные кодируются в формат **Base64** и на выходе мы получаем что-то в роде того:
Точки как раз разделяют части токена
```json
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```

# Процесс получения JWT
1) Пользователь отправляет на сервер запрос на аутенфикацию, прикладывая, к примеру, логин и пароль
2) Сервер аутенфикации создает JWT и отправляет его пользователю
3) Сайт, получивший JWT сохраняет его у себя для дальнейших запросов
4) Теперь при любом следующем запросе сайт прикладывает этот JWT как ключ
5) Если токен истек, то сервер возвращает ошибку 401
6) В таком случае сайт переадресовывает пользователя на страницу логина

То есть если бы не было токена, нам бы пришлось вводить каждый раз свой логин и пароль при попытке отправить запрос на сервер, звучит говняно.

# Реальный пример
Пример будет основан на фейковом API - JSON Server + JWT

Создадим компонент для страницы логина: 
(Не надо бездушно копировать код, я половину сокращаю для краткости)
*Login.vue*
```vue
<template>
  <div>
    <h1>Welcome to my project!</h1>
    <v-card>
      <v-form>
        <v-container>
        
          <v-text-field v-model="email"></v-text-field>
          <v-text-field v-model="password"></v-text-field>
          
          <v-btn @click="tryLogin">Log in</v-btn>
          
        </v-container>
      </v-form>
    </v-card>
  </div>
</template>

<script>
export default {
	data() {
		return {  
		  email: '',  
		  password: '',  
		}
	},
	methods: {
		tryLogin() {
	      axios.post('http://localhost:8000/auth/login', {
	        email: this.email,
	        password: this.password
	      }).then(response => {
	        localStorage.setItem('token', response.data.access_token)
	        this.$router.push({ name: 'Products' })
	      }).catch(error => {
	        alert(error.response.data.message)
	      })
	    }
	}
}
</script>
```

Здесь через v-model мы привязываем инпуты к переменным email и password.
Теперь приглядимся к методу tryLogin:
```js
tryLogin() {
	axios.post('http://localhost:8000/auth/login', {
	
	    email: this.email,
	    password: this.password
	    
	}).then(response => {
	
	    localStorage.setItem('token', response.data.access_token)
	    this.$router.push({ name: 'Products' })
	    
	}).catch(error => {
	
	    alert(error.response.data.message)
	    
	})
}
```

Отправляем запрос на адрес http://localhost:8000/auth/login

И в качестве **body(payload)** **POST** запроса передаем логин и пароль.

*Это всегда делают через POST запрос, потому что данные в его теле в безопасности (подробнее в гугле про HTTP запросы)*
```js
axios.post('http://localhost:8000/auth/login', {
	email: this.email,
	password: this.password
})
```

Получив ответ, обрабатываем его через then и catch:
callback внутри then отработает на успешный ответ, а callback внутри catch - на ошибку.

Если ответ успешный, то нам с сервера пришел токен. 
Чтобы понять, где он находится, можно прочитать документацию (для слабаков) или вывести ответ в консоль (для мужиков).
В нашем случае он находится по пути *response.data.access_token*
Достаем его оттуда и кладем в localStorage.
Так как ответ успешный, это означает, что пользователь авторизовался, можно сразу же перевести его на главную страницу через *$router.push*

```js
.then(response => {
	localStorage.setItem('token', response.data.access_token)
	this.$router.push({ name: 'Products' })  
})
```

Если же произошла ошибка, то нужно проинформировать об этом пользователя:
- Сделать систему обработки ошибок (для мальчиков)
- Запустить alert (для мужчин)

Нужно еще понять, где находится сообщение об ошибке, но *мужики* уже знают профессиональный способ, поэтому, когда нашли, выводим ее не менее профессионально:
```js
.catch(error => {
	alert(error.response.data.message)
})
```

# Страница Products
До этого мы работали с **API** для игр, которая не требует авторизации, поэтому можно спокойно удалить все связанные с ней компоненты.

Если посмотреть в файлы нашего JSON Server, то там есть файл **database.json**, который имитирует базу данных и тупо хранит в себе набор JSON объектов.

К примеру, там есть следующие поля:
```json
{
	"products": [...],
	"locations": [...],
	"families": [...],
	...
}
```

Чтобы, к примеру, получить массив products, нужно отправить запрос на такой адрес:
```
http://localhost:8000/products
```

Абсолютно аналогично для других полей, также мы можем создавать собственные данные (после этого нужно перезагрузить сервер).

В таком случае создаем компонент **Products**, который будет один в один как и компоненты **Games и Developers** выводить список полученных с сервера объектов.

Добавим его в роутер:
*router.js*
```js
import Products from './components/Products.vue';

const routes = [
	...
	{
		name: 'Products',
		path: '/products',
		component: Products
	}
]
```

И отправим тестовый запрос.
Как отправить запрос?
- Перебрать варианты или догадаться (для сеньер 300к/наносек альфа самец)
- Прочитать документацию (для стажер 20к/год девелопер)

*Products.vue*
```vue
<template>
	<div>Я будущий Products!</div>
</template>
<script>
import axios from 'axios';

export default {
	name: "Products",
	mounted() {
		const token = localStorage.getItem('token');
		
		axios.get('http://localhost:8000/products', {
			headers: {
				Authorization: `Bearer ${token}`
			}
		}).then(response => {
			console.log(response)
		}).catch(e => {
			console.log(e)
		}) 
	}
}
</script>
```

В нашем случае нам нужно добавить токен в заголовки запроса под именем **Authorization** и в начале написать **Bearer**, что переводится как *предъявитель*.
То есть мы так обозначаем себя как предъявителя токена.

Если пришел успешный ответ, можно заняться выводом этих данных:
Создадим переменную **products** в data и будем выводить ее в шаблоне:
```vue
<template>
  <v-card>
    <v-container>
      <v-row>
        <v-col v-for="product in products" :key="product.id">
          <v-card>
            <v-card-text>
              {{ product.id }}
            </v-card-text>
          </v-card>
        </v-col>
      </v-row>
    </v-container>
  </v-card>
</template>
```

Думаю, альфа 300к/наносек самцам не нужно объяснять, как в эту переменную после ответа засунуть данные.

# Архитектура
Насколько будет удобным сайт, если нам придется вводить свои логин и пароль каждый раз, когда мы будем заходить на него?

Каким то образом, к примеру, вконтакте, запоминает, что пользователь уже был авторизован, но как?

Легко заметить, что после авторизации мы сохраняем токен в localStorage, который известен тем, что данные в нем хранятся вечно, пока их вручную не удалят.

Поэтому мы можем делать проверку - если токен есть в localStorage, то пользователь был авторизован и можно пустить его на главную страницу, иначе отправить на страницу входа.

А что, если токен неправильный? 
В любом случае при заходе на главную страницу начнут отправляться разные запросы на получение данных, к которым будет прикладываться этот токен и сервер, проверив его, будет вернет соответствующую ошибку.

Чтобы отлавливать эту ошибку, каждый наш запрос на сервер будет выглядеть так:
```js
	const token = localStorage.getItem('token')
 
    if (token) {
      axios.get('http://localhost:8000/products', {
        headers: {
          Authorization: `Bearer ${token}a`
        }
      }).then(response => {
        this.products = response.data
        alert('Успех!')
      }).catch(error => {
        alert(error.response.data.message)
 
        if (error.response.status === 401) {
          localStorage.clear()
          this.$router.push('/login')
        }
      })
    }
```

Красота, да?
Представим кинотеатр, на входе стоит **один** человек, который проверяет у **всех** входящих людей наличие билета - звучит адекватно.
А в нашем случае получается так, что на за **каждым** посетителем закреплен **отдельный** работник, который следит, есть ли у него билет. Не перебор ли?

Правильная схема нашего приложения должна быть следующая:

![[Application-Server interaction.png]]

Между приложением и сервером должен быть своего рода секретарь, который обрабатывает все поступающие и отправляющиеся запросы. Он будет добавлять JWT токен в запрос и пенаправлять пользователя на страницу входа, если сервер сказал, что токен говно.
В таком случае на стороне приложения мы сможем сконцентрироваться только на логике, не задумываясь о том, что там происходит с запросами.

В этом нам помогут **interceptors** (intercept - перехватывать).
В нашем случае интерцепторы - это функции, которые вызываются axios'ом перед тем, как запрос придет получателю или отправится.
Они что то делают с этим запросом и отправляют его дальше.

# Axios instance
Сначала уйдем немного от темы интерцепторов и создадим инстанс axios'а.
Для чего он нужен:
Сейчас мы при отправлении каждого запроса указываем адрес сервера вручную, это стремно, ведь мы можем сделать ошибку или, если этот адрес поменяется, то и вовсе придется весь сайт перелопатить, дабы его там изменить.

В голову приходит сделать отдельную переменную с адресом, которую мы будем импортить везде, где хотим отправить запрос.

Но также нам может пригодиться с каждым запросом отправлять заголовки, параметры, указать метаданные для axios'а, такие как timeout запроса и так далее.

Мы бы могли это сделать в интерцепторе, однако вдруг у нас есть 2 разных сервера и тогда нужно еще и дополнительно проверять, на какой из них конкретно мы шлем?

Для этого axios предоставляет очень удобный инструмент. Мы можем создать экземпляр (инстанс) аксионса с заранее установленными параметрами:
```js
const baseURL = 'http://localhost:8000/';  
const instance = axios.create({  
    baseURL,  
    timeout: 10000,  
    withCredentials: true  
})
```

Теперь всякий раз, когда мы хотим отправить запрос, нам нужно будет вызывать методы уже не у глобального объекта axios, а у этого экземпляра:
```js
instance.get('products', ...)
```

Причем и путь не нужно указывать полностью, а только ту часть, которая идет после baseURL.

# Интерцепторы
Интерцепторы можно навесить на глобальный объект axios:
```js
axios.interceptors.request.use(onRequest);
axios.interceptors.response.use(onSuccess, onError);
```

Тогда переданные функции будут обрабатывать **все** входящие и выходящие запросы.
Однако, как и говорилось раньше, что, если у нас вдруг два сервера?
В таком случае опять же будет очень удобно сделать 2 отдельных инстанса axios'а под каждый сервак и интерцепторы уже вешать отдельно на каждый из них.

# Практика
### Request interceptor
Сначала напишем интерцептор, который перед отправкой запроса будет добавлять в него токен, если он есть в localStorage:
```js
function addAccessToken(request) {
	const token = localStorage.getItem('token');
	
	if (token) {
		request.headers.Authorization = `Bearer ${token}`;
	}
	
	return request;
}
```

Как видно, в нашем случае интерцептор - это *обычная* функция, которая принимает *обычный* объект, который можно вывести в консоль и глянуть, что там вообще такое.
Этот объект и есть наш запрос, никакой магии.
Далее эта функция модифицирует этот объект, добавляя в заголовки свойство **Authorization** и возвращает этот объект обратно.

Осталось зарегистрировать ее как перехватчик:
```js
const instance = axios.create({ ... });
instance.interceptors.request.use(addAccessToken);
```

Вот и все, теперь вместо этого:
```js
axios.get('http://localhost:8000/products', {  
  headers: {  
    Authorization: `Bearer ${token}a`  
  }  
})
```

Можно писать так:
```js
instance.get('products')
```

### Response interceptor
Теперь будем обрабатывать ответы от сервера.
Если пришел 401 (unathorized), то сделаем редирект на страницу логина.
Если же обычная ошибка, то выведем ее в alert (по мужски).

Здесь в функцию **use** нужно передать 2 функции:
- Первая будет обрабатывать успешный ответ
- Вторая будет обрабатывать ошибку

В нашем случае первая функция не будет ничего делать, просто примет объект ответа и тут же его вернет, а вот с функцией обработки ошибки уже веселее:
```js
import router from "../router.js";

instance.interceptors.response.use(r => r, error => {  
    if (error.response.status === 401) {
	    localStorage.clear()
        router.push({ name: 'Login' })  
    }  
  
    const message = error.response?.data?.message;  
    if (message) {  
        alert(message)  
    }  
  
    return error  
})
```

Тут все так прсто, что даже объяснять нечего.
Теперь посмотрим, как у нас преобразился запрос в компоненте Products:

*Было*
```js
const token = localStorage.getItem('token')
 
if (token) {
    axios.get('http://localhost:8000/products', {
    headers: {
        Authorization: `Bearer ${token}a`
    }
    }).then(response => {
	    this.products = response.data
	    alert('Успех!')
    }).catch(error => {
        alert(error.response.data.message)
 
	    if (error.response.status === 401) {
	        localStorage.clear()
	        this.$router.push('/login')
	    }
    })
}
```

Стало
```js
instance.get('products').then(response => {  
  this.products = response.data  
})
```

