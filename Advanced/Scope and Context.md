# Scope VS Context
*Scope* - область видимости.
*Context* - контекст вызова.

Каждый вызов функции имеет собственную область видимости и контекст вызова, связанный с ним.

Фундаментально, область видимости основывается на функции, когда контекст основывается на объекте.

Другими словами, *область видимости* отвечает за доступ к переменным, который имеет функция при вызове, и он уникальный каждый раз.

*Контекст* - это всегда значение ключевого слова *this*, которое является ссылкой на объект, которому *принадлежит* выполняемый в данный момент код.

Переменная может быть определена в *локальной* или *глобальной* области видимости, которая отвечает за доступ к переменным из других областей видимости в течении времени выполнения.

Любая *глобальная переменная* (определенная в глобальной области видимости, то есть за пределами какой-либо функции) будет жить в течении всего времени выполнения программы и может быть доступна из любой ее точки.

*Локальные переменные* могут быть доступны или изменены только в рамках *тела функции*, в которой они определены и будут иметь разную область видимости на каждый вызов этой функции.

*ES6* представил новые ключевые слова *let* и *const*, которые поддерживают объявление переменных в *блочной* области видимости.
Это означает, что, если переменная ограничена блоком, к примеру *if*, *for* или даже просто *{}*, то она будет недоступна за пределами этого блока.
Это работает противоположно переменным, объявленным через *var*, которые могут быть доступны за пределами блока.

Другими словами, у *let* и *const* блочная область видимости, а у *var* - функциональная.

Разница между *let* и *const*:
*const* - read-only *ссылка* на значение. 
*let* - mutable *ссылка* на значение.

То есть это не означает, что *значение* переменной неизменяемо - изменять нельзя только идентификатор этого значения, то есть ссылку.

## Что такое контекст
Чаще всего *контекст* определяется тем, как функция вызывается.

Когда она вызывается в качестве метода, *this* становится ссылкой на объект, что содержит данный метод.
```js
var obj = {
    foo: function() {
        return this;   
    }
};

obj.foo() === obj; // true
```

Аналогично работает, когда мы вызываем *функцию* как *конструктор объекта*, в таком случае *this* в области видимости данной функции будет ссылаться на *созданный* объект:

```js
function foo() {
    alert(this);
}

foo() // window
new foo() // foo
```

Если функция вызвана без привязки к контексту, то *this* будет ссылаться на *глобальный контекст* (*window* в браузере).
Если же функция выполняется в строгом режиме, то контекст будет равен *undefined*.

```js
function b() {
  console.log('THIS FROM b')
  console.log(this)
}

function a() {
  console.log('THIS FROM a')
  console.log(this)
  
  b()
}

a()

// THIS FROM a
// window
// THIS FROM b
// window
```

## Контекст выполнения
*JavaScript* - однопоточный язык, другими словами, только одна задача может быть выполнена в одно время.
Когда *интерпретатор* JS первый раз запускает код, он в первую очередь входит в *глобальный контекст выполнения* по умолчанию

Каждый вызов функции из этой точки будет приводить к созданию нового *контекста выполнения*.

Вот здесь и возникает путаница. Термин *контекст выполнения* на самом деле относится скорее к *области видимости*, чем к *контексту*, который мы обсуждали ранее.
Это неудачное соглашение об именовании, однако это терминология, определенная *ECMAScript спецификацией* ничего не поделаешь.

Каждый раз, когда создается новый *контекст выполнения*, он добавляется на верх стека выполнения.
Браузер будет всегда выполнять *текущий контекст выполнения*, который находится на самом верху.
Когда он закончит, этот контекст будет удален из верха и контроль вернется *контексту выполнения* ниже.

*Контекст выполнения* может быть разделен на две фазы: **фазу создания** и **фазу выполнения**.

**В фазе создания**, интерпретатор сначала создаст *variable object*, который еще называют *activation object*, который содержит все переменные, объявления функций и аргументов, определенных внутри *контекста выполнения*.
Отсюда следующим шагом начинается инициализация *цепочки областей видимости*, а потом уже в самом конце определяется значение *this*.

Дальше начинается **фаза выполнения**, код интерпретируется и выполняется.

## Цепочка областей видимости
Для каждого контекста вызова существует цепочка областей видимости, соединенная с ним.

Цепь содержит объект переменных для каждого контекста вызова в стеке вызова.
Он используется для определения доступа к переменным и разрешения идентификаторов.

```js
function first() {
    second();
    function second() {
        third();
        function third() {
            fourth();
            function fourth() {
                // do something
            }
        }
    }   
}

first();
```

Вложенные функции будут вызваны по очереди до последней с именем *fourth*.

Начиная от нее, цепочка областей видимости будет с верху вниз: *fourth third, second, first, global*.

Функция *fourth* будет иметь доступ ко всем *глобальным переменным* и к переменным, определенным в функциях *first*, *second*, *third*.

Конфликты имен разрешаются подъемом по цепочке областей, от локальных до глобальных.
Если переменные имеют одно и то же имя, то преимущество отдается первой локальной.

Другими словами, каждый раз, когда мы пытаемся получить доступ к переменной, процесс поиска начнется с *собственного объекта переменных* данной функции и вверх по *цепочке областей видимости*.

## Замыкания
Попытка получить доступ к переменной за пределами собственной области видимости называется *замыканием*.

Другими словами, *замыкание* формируется, когда вложенная функция определяется внутри другой функции, и получает доступ к переменным, находящимся выше по цепочки областей видимости.

Если мы вернем вложенную функцию, она не потеряет доступ к внешним областям видимости, который был ей дан в момент определения.

Эта инкапсуляция позволяет скрывать и сохранять контекст выполнения от внешних областей видимости, одновременно предоставляя публичный интерфейс взаимодействия с данным контекстом, к примеру:

```js
function foo() {
    var localVariable = 'private variable';
    return function() {
        return localVariable;
    }
}

var getLocalVariable = foo();
getLocalVariable() // "private variable"
```

Один из самых популярных видов использования замыканий знаком под именем *module pattern*.
Он позволяет *эмулировать* поведение ключевых слов *public, private, priveleged*.

```js
var Module = (function() {
    var privateProperty = 'foo';

    function privateMethod(args) {
        // do something
    }

    return {

        publicProperty: '',

        publicMethod: function(args) {
            // do something
        },

        privilegedMethod: function(args) {
            return privateMethod(args);
        }
    };
})();
```

Другая разновидность использования замыкания - *IIFE*.
```js
(function(window) {
          
    var foo, bar;

    function private() {
        // do something
    }

    window.Module = {

        public: function() {
            // do something }
    };

})(this);
```

## Call and Apply
Эти два метода, которые есть у всех функций позволяют вызвать любую функцию в любом желаемом контексте.

Отличие между *call* и *apply* в том, что первая требует, чтобы аргументы были перечислены в момент вызова, когда apply принимает массив аргументов

```js
function user(firstName, lastName, age) {
    // do something }

user.call(window, 'John', 'Doe', 30);
user.apply(window, ['John', 'Doe', 30]);
```

*Function.prototype.bind* - привязывает функцию к определенному контексту.

Возможный полифилл:
```js
if(!('bind' in Function.prototype)){
    Function.prototype.bind = function() {
        var fn = this;
        var context = arguments[0];
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
            return fn.apply(context, args.concat([].slice.call(arguments)));
        }
    }
}
```

Это пригождается, когда нам нужно вручную менять контекст.
К примеру, при использовании *addEventListener* на *DOM узле*, контекст автоматически привязывается к обработчику события.
Однако, если мы создаем, к примеру, объект-обертку на основе ООП для нашего узла или нескольких узлов, контекст привязывать придется вручную:

```js
function Widget() {
    this.element = document.createElement('div');
    this.element.addEventListener('click', this.onClick.bind(this), false);
}

Widget.prototype.onClick = function(e) {
    // do something
};
```

Также *call* и *apply* позволяют вызвать методы объектов на других объектах, которые работают похожим образом.
К примеру методы массивов на псевдомассивах:
```js
Array.prototype.slice.call(arguments, 1)
[].slice.call(arguments)
```

Или вызвать метод *superclass'a* внутри метода потомка в его контексте:
```js
SubClass.prototype.init = function(){
    // call the superclass init method in the context of the "SubClass" instance
    SuperClass.prototype.init.apply(this, arguments);
}
```
